# 生成 MCP Server 客户端接入规则
你正在为 `task-plan-mcp-server` MCP Server 生成客户端接入规则。

# 示例如下
```markdown
## task-plan-mcp-server 客户端接入规则

## 项目概述

task-plan-mcp-server 是基于 Python + ReMe 内存集成的任务规划与动态工具规划 MCP Server，通过 SSE 协议提供上下文管理、规划反馈和动态规划能力。

## 工具列表

当前 MCP Server 提供3个工具：
1. `create_context` - 创建规划上下文
2. `decision` - 动态规划下一步行动序列
3. `report_action_result` - 统一上报执行结果和决策反馈

### 核心设计理念

**基于 React 思想的状态同步机制**：
- 每次状态变更（决策、工具调用结果）必须立即同步到上下文记忆
- 内存是单一数据源，任何变更都应实时反映
- decision 返回的 steps 需要客户端执行，每步完成后需调用 report_action_result 上报
- next_action 是建议的后续操作列表

### 强制使用规则

**你必须严格遵循以下工具使用规则：**

1. **每个任务必须创建上下文**：执行任何操作前，必须调用 `mcp_task_plan_server_create_context` 创建上下文
2. **工具调用后必须记录反馈**：每次调用工具后，必须调用 `mcp_task_plan_server_report_action_result` (type: "tool_execution_feedback") 保存执行结果
3. **重要决策必须记录**：每个关键决策点必须调用 `mcp_task_plan_server_report_action_result` (type: "plan_feedback") 记录决策和原因
4. **任务结束前必须兜底检查**：任务执行完毕前，必须调用 report_action_result 上报所有遗漏的决策和结果

### 工具详细定义

#### 1. mcp_task_plan_server_create_context

**用途**：创建规划上下文，隔离任务记忆

**必需参数**：
- `name`: 上下文名称（字符串，必填）

**可选参数**：
- `description`: 任务描述（字符串）
- `parent_context_id`: 父上下文ID（字符串，用于复用历史记忆）
- `agent`: 代理信息（对象，包含 name、role、environment、terminal_type、terminal_user）

**调用时机**：每个任务开始时必须调用

**返回**：
```json
{
  "success": true,
  "context_id": "ctx_xxx",
  "name": "任务名称",
  "description": "任务描述",
  "created_at": "2024-01-01T00:00:00"
}
```

**示例**：
```json
{
  "name": "feature_development",
  "description": "开发用户认证模块",
  "agent": {"name": "Trae", "role": "software_engineer"}
}
```

#### 2. mcp_task_plan_server_decision

**用途**：根据任务动态规划下一步行动序列，返回执行步骤和建议的后续操作

**必需参数**：
- `context_id`: 上下文ID（字符串，必填）
- `query`: 查询内容（字符串，必填）

**可选参数**：
- `tools`: 动态工具定义数组（数组），包含以下字段：
  - `domain`: 工具领域（字符串，必填）
  - `tool_name`: 工具名称（字符串，必填）
  - `description`: 工具描述（字符串，必填）
  - `args`: 参数定义（对象）
  - `input`: 输入结构（对象）
  - `output`: 输出结构（对象）

**返回**：
```json
{
  "success": true,
  "plan_id": "plan_xxx",
  "context_id": "ctx_xxx",
  "query": "用户查询",
  "steps": [
    {"step_id": "step_1", "tool_name": "Read", "domain": "file_system", "parameters": {}, ...},
    {"step_id": "step_2", "tool_name": "Write", "domain": "file_system", "parameters": {}, ...}
  ],
  "continuation": [],
  "context": {},
  "created_at": "2024-01-01T00:00:00",
  "next_action": [
    {"tool_name": "decision", "domain": "system", "condition": "if next need continue decision"},
    {"tool_name": "report_action_result", "domain": "system", "condition": "if next need continue report action result"}
  ]
}
```

**steps 结构**：
- `step_id`: 步骤唯一ID
- `tool_name`: 工具名称
- `domain`: 工具领域
- `parameters`: 调用参数
- `depends_on`: 依赖步骤列表
- `reasoning`: 执行原因
- `expected_output`: 期望输出

**next_action 结构**（建议的后续操作）：
- `tool_name`: 建议的工具名称
- `domain`: 工具领域
- `condition`: 触发条件

**调用时机**：
- 遇到复杂任务需要规划时
- 不确定下一步操作时
- 需要查询历史经验时

**示例**：
```json
{
  "context_id": "ctx_123",
  "query": "开发用户认证模块",
  "tools": [
    {"domain": "file", "tool_name": "Write", "description": "写入文件", "args": {}, "input": {}, "output": {}}
  ]
}
```

#### 3. mcp_task_plan_server_report_action_result (type: "plan_feedback")

**用途**：保存重要决策和用户反馈

**必需参数**：
- `context_id`: 上下文ID（字符串，必填）
- `type`: 设为 "plan_feedback"
- `messages`: 消息数组（数组，必填）

**messages 结构**：
- `role`: 角色（"user"/"assistant"/"tool"，必填）
- `content`: 内容（字符串，必填）

**可选参数**：
- `plan_id`: 计划ID（字符串）
- `metadata`: 元数据（对象）

**示例**：
```json
{"context_id": "ctx_123", "type": "plan_feedback", "messages": [{"role": "user", "content": "改用异步处理"}]}
```

#### 4. mcp_task_plan_server_report_action_result (type: "tool_execution_feedback")

**用途**：保存工具执行结果反馈，同时保存 messages 到 plan_feedback

**必需参数**：
- `context_id`: 上下文ID（字符串，必填）
- `type`: 设为 "tool_execution_feedback"
- `tool_execution_feedback`: 执行反馈数组（数组，必填）

**tool_execution_feedback 结构**：
- `tool_name`: 工具名称（字符串，必填）
- `success`: 是否成功（布尔值，必填）
- `input`: 输入参数（任意类型）
- `output`: 输出结果（任意类型）
- `execution_time`: 执行时间（数字）
- `error`: 错误信息（字符串）
- `step_id`: 步骤ID（字符串）
- `domain`: 工具领域（字符串）
- `create_time`: 创建时间（字符串）
- `token_cost`: token消耗（整数）

**可选参数**：
- `plan_id`: 计划ID（字符串）
- `messages`: 消息数组
- `metadata`: 元数据（对象）

**示例**：
```json
{
  "context_id": "ctx_123",
  "type": "tool_execution_feedback",
  "plan_id": "plan_456",
  "tool_execution_feedback": [
    {
      "step_id": "step_1",
      "tool_name": "Read",
      "domain": "file_system",
      "success": true,
      "input": {"file_path": "/src/main.py"},
      "output": {"content": "..."},
      "execution_time": 150
    }
  ]
}
```

### 任务执行流程

#### 第一阶段：任务开始

1. 调用 `create_context` 创建上下文
2. 记录返回的 `context_id`

#### 第二阶段：任务规划

1. 调用 `decision` 获取 `steps` 执行步骤
2. 按顺序执行 `steps` 中的每个步骤
3. 每步执行完毕后立即调用 `report_action_result` (type: "tool_execution_feedback") 上报结果
4. 遇到重要决策时立即调用 `report_action_result` (type: "plan_feedback")
5. 检查返回的 `next_action`，按需继续调用

#### 第三阶段：任务收尾

1. 确认所有 `steps` 已执行完毕
2. 确认 `report_action_result` 已调用
3. 如有遗漏，立即补报

### 错误处理

**工具调用失败时：**
1. 记录失败到 `report_action_result` (type: "tool_execution_feedback")
2. 填写详细 error 信息
3. 尝试替代方案
4. 多次失败则调用 `report_action_result` (type: "plan_feedback") 记录问题

### 关键建议

1. **响应式同步**：每次决策或调用后立即上报
2. **复用上下文**：通过 parent_context_id 复用相似任务记忆
3. **详细记录反馈**：每个工具执行结果都应记录
4. **及时记录决策**：当时记录最准确
5. **最后执行 report_action_result**：确保内存一致性
```
# 输出格式
1. 在.trae/rules/project_rules.md 输出完整的 project_rules.md 文件内容，使用 Markdown 格式。
2. 尽量排版紧凑，字数不超过500字
